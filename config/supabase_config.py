# supabase_config.py
"""
Supabase Configuration for Auction Data Collection System
"""

import os
from dotenv import load_dotenv
load_dotenv()
from supabase import create_client, Client
from typing import Dict, List, Optional, Any
import logging
from datetime import datetime

# Supabase Configuration
SUPABASE_CONFIG = {
    "url": os.environ["SUPABASE_URL"],
    "key": os.environ["SUPABASE_ANON_KEY"],
    "service_role_key": os.environ["SUPABASE_SERVICE_ROLE_KEY"]
}

# Database connection settings
DATABASE_CONFIG = {
    "max_connections": 20,
    "timeout": 30,
    "retry_attempts": 3,
    "batch_size": 1000,
    "connection_timeout": 60
}

# Logging configuration
LOGGING_CONFIG = {
    "level": "INFO",
    "format": "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    "files": {
        "main": "auction_data_main.log",
        "extraction": "auction_data_extraction.log",
        "listing": "auction_data_listing.log",
        "errors": "auction_data_errors.log"
    },
    "directory": "logs"
}

# Table definitions for Supabase
TABLE_DEFINITIONS = {
    "vehicles": {
        "description": "Main table for vehicle listings from auction sites",
        "columns": {
            "id": "BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY",
            "site_name": "VARCHAR(100) NOT NULL",
            "lot_number": "VARCHAR(100) NOT NULL",
            "make": "VARCHAR(100)",
            "model": "VARCHAR(100)",
            "year": "INTEGER",
            "mileage": "INTEGER",
            "start_price": "INTEGER",
            "end_price": "INTEGER",
            "grade": "VARCHAR(50)",
            "color": "VARCHAR(50)",
            "result": "VARCHAR(50)",
            "scores": "VARCHAR(200)",
            "url": "TEXT",
            "lot_link": "TEXT",
            "search_date": "DATE",
            "created_at": "TIMESTAMP WITH TIME ZONE DEFAULT NOW()",
            "last_updated": "TIMESTAMP WITH TIME ZONE DEFAULT NOW()"
        },
        "indexes": [
            "CREATE INDEX idx_vehicles_site_lot ON vehicles(site_name, lot_number)",
            "CREATE INDEX idx_vehicles_make_model ON vehicles(make, model)",
            "CREATE INDEX idx_vehicles_year ON vehicles(year)",
            "CREATE INDEX idx_vehicles_search_date ON vehicles(search_date)",
            "CREATE INDEX idx_vehicles_created_at ON vehicles(created_at)"
        ],
        "constraints": [
            "ALTER TABLE vehicles ADD CONSTRAINT unique_site_lot UNIQUE (site_name, lot_number)"
        ]
    },
    
    "processed_urls": {
        "description": "Tracks which URLs have been processed for detailed extraction",
        "columns": {
            "id": "BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY",
            "site_name": "VARCHAR(100) NOT NULL",
            "url": "TEXT NOT NULL",
            "processed": "BOOLEAN DEFAULT FALSE",
            "processing_started": "TIMESTAMP WITH TIME ZONE",
            "processing_completed": "TIMESTAMP WITH TIME ZONE",
            "error_message": "TEXT",
            "retry_count": "INTEGER DEFAULT 0",
            "created_at": "TIMESTAMP WITH TIME ZONE DEFAULT NOW()",
            "last_updated": "TIMESTAMP WITH TIME ZONE DEFAULT NOW()"
        },
        "indexes": [
            "CREATE INDEX idx_processed_urls_site ON processed_urls(site_name)",
            "CREATE INDEX idx_processed_urls_processed ON processed_urls(processed)",
            "CREATE INDEX idx_processed_urls_created_at ON processed_urls(created_at)"
        ],
        "constraints": [
            "ALTER TABLE processed_urls ADD CONSTRAINT unique_site_url UNIQUE (site_name, url)"
        ]
    },
    
    "detailed_auction_data": {
        "description": "Detailed auction data extracted from individual lot pages",
        "columns": {
            "id": "BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY",
            "vehicle_id": "BIGINT REFERENCES vehicles(id)",
            "site_name": "VARCHAR(100) NOT NULL",
            "lot_number": "VARCHAR(100) NOT NULL",
            "url": "TEXT NOT NULL",
            "make": "VARCHAR(100)",
            "model": "VARCHAR(100)",
            "year": "INTEGER",
            "mileage": "INTEGER",
            "start_price": "INTEGER",
            "final_price": "INTEGER",
            "grade": "VARCHAR(50)",
            "color": "VARCHAR(50)",
            "result": "VARCHAR(50)",
            "auction_date": "DATE",
            "engine_size": "VARCHAR(50)",
            "transmission": "VARCHAR(50)",
            "fuel_type": "VARCHAR(50)",
            "drive_type": "VARCHAR(50)",
            "body_style": "VARCHAR(50)",
            "doors": "INTEGER",
            "seats": "INTEGER",
            "inspection_score": "VARCHAR(50)",
            "exterior_condition": "VARCHAR(100)",
            "interior_condition": "VARCHAR(100)",
            "additional_info": "JSONB",
            "images": "JSONB",
            "extraction_date": "TIMESTAMP WITH TIME ZONE DEFAULT NOW()",
            "created_at": "TIMESTAMP WITH TIME ZONE DEFAULT NOW()",
            "last_updated": "TIMESTAMP WITH TIME ZONE DEFAULT NOW()"
        },
        "indexes": [
            "CREATE INDEX idx_detailed_auction_vehicle_id ON detailed_auction_data(vehicle_id)",
            "CREATE INDEX idx_detailed_auction_site_lot ON detailed_auction_data(site_name, lot_number)",
            "CREATE INDEX idx_detailed_auction_make_model ON detailed_auction_data(make, model)",
            "CREATE INDEX idx_detailed_auction_year ON detailed_auction_data(year)",
            "CREATE INDEX idx_detailed_auction_date ON detailed_auction_data(auction_date)"
        ],
        "constraints": [
            "ALTER TABLE detailed_auction_data ADD CONSTRAINT unique_detailed_site_lot UNIQUE (site_name, lot_number)"
        ]
    },
    
    "staging_vehicles": {
        "description": "Staging table for temporary vehicle data processing",
        "columns": {
            "id": "BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY",
            "site_name": "VARCHAR(100) NOT NULL",
            "lot_number": "VARCHAR(100) NOT NULL",
            "make": "VARCHAR(100)",
            "model": "VARCHAR(100)",
            "year": "INTEGER",
            "mileage": "INTEGER",
            "start_price": "INTEGER",
            "end_price": "INTEGER",
            "grade": "VARCHAR(50)",
            "color": "VARCHAR(50)",
            "result": "VARCHAR(50)",
            "scores": "VARCHAR(200)",
            "url": "TEXT",
            "lot_link": "TEXT",
            "search_date": "DATE",
            "processed": "BOOLEAN DEFAULT FALSE",
            "created_at": "TIMESTAMP WITH TIME ZONE DEFAULT NOW()"
        },
        "indexes": [
            "CREATE INDEX idx_staging_vehicles_processed ON staging_vehicles(processed)",
            "CREATE INDEX idx_staging_vehicles_site ON staging_vehicles(site_name)",
            "CREATE INDEX idx_staging_vehicles_created_at ON staging_vehicles(created_at)"
        ]
    },
    
    "auction_sites": {
        "description": "Configuration table for auction sites",
        "columns": {
            "id": "BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY",
            "site_name": "VARCHAR(100) UNIQUE NOT NULL",
            "display_name": "VARCHAR(200)",
            "base_url": "TEXT",
            "auction_url": "TEXT",
            "username": "VARCHAR(100)",
            "password": "VARCHAR(100)",
            "active": "BOOLEAN DEFAULT TRUE",
            "rate_limit": "INTEGER DEFAULT 2",
            "max_concurrent": "INTEGER DEFAULT 3",
            "created_at": "TIMESTAMP WITH TIME ZONE DEFAULT NOW()",
            "last_updated": "TIMESTAMP WITH TIME ZONE DEFAULT NOW()"
        },
        "indexes": [
            "CREATE INDEX idx_auction_sites_active ON auction_sites(active)",
            "CREATE INDEX idx_auction_sites_name ON auction_sites(site_name)"
        ]
    },
    
    "manufacturers": {
        "description": "Configuration table for vehicle manufacturers and models",
        "columns": {
            "id": "BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY",
            "manufacturer": "VARCHAR(100) NOT NULL",
            "make": "VARCHAR(100) NOT NULL",
            "model": "VARCHAR(100) NOT NULL",
            "active": "BOOLEAN DEFAULT TRUE",
            "created_at": "TIMESTAMP WITH TIME ZONE DEFAULT NOW()"
        },
        "indexes": [
            "CREATE INDEX idx_manufacturers_make ON manufacturers(make)",
            "CREATE INDEX idx_manufacturers_active ON manufacturers(active)"
        ]
    },
    
    "extraction_logs": {
        "description": "Logs for extraction processes",
        "columns": {
            "id": "BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY",
            "site_name": "VARCHAR(100)",
            "operation": "VARCHAR(100)",
            "status": "VARCHAR(50)",
            "records_processed": "INTEGER",
            "errors": "INTEGER",
            "start_time": "TIMESTAMP WITH TIME ZONE",
            "end_time": "TIMESTAMP WITH TIME ZONE",
            "duration": "INTEGER",
            "error_message": "TEXT",
            "created_at": "TIMESTAMP WITH TIME ZONE DEFAULT NOW()"
        },
        "indexes": [
            "CREATE INDEX idx_extraction_logs_site ON extraction_logs(site_name)",
            "CREATE INDEX idx_extraction_logs_operation ON extraction_logs(operation)",
            "CREATE INDEX idx_extraction_logs_status ON extraction_logs(status)",
            "CREATE INDEX idx_extraction_logs_created_at ON extraction_logs(created_at)"
        ]
    },
    
    "email_campaigns": {
        "description": "Generated email campaigns for vehicle makes/models",
        "columns": {
            "id": "BIGINT PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY",
            "campaign_name": "VARCHAR(200)",
            "make": "VARCHAR(100)",
            "model": "VARCHAR(100)",
            "email": "VARCHAR(300)",
            "domain": "VARCHAR(100)",
            "generated_at": "TIMESTAMP WITH TIME ZONE DEFAULT NOW()",
            "status": "VARCHAR(50) DEFAULT 'generated'"
        },
        "indexes": [
            "CREATE INDEX idx_email_campaigns_make ON email_campaigns(make)",
            "CREATE INDEX idx_email_campaigns_domain ON email_campaigns(domain)",
            "CREATE INDEX idx_email_campaigns_generated_at ON email_campaigns(generated_at)"
        ]
    }
}

# SQL functions for database operations
SQL_FUNCTIONS = {
    "update_last_updated": """
        CREATE OR REPLACE FUNCTION update_last_updated_column()
        RETURNS TRIGGER AS $$
        BEGIN
            NEW.last_updated = NOW();
            RETURN NEW;
        END;
        $$ language 'plpgsql';
    """,
    
    "trigger_vehicles_updated": """
        CREATE TRIGGER update_vehicles_last_updated
        BEFORE UPDATE ON vehicles
        FOR EACH ROW
        EXECUTE FUNCTION update_last_updated_column();
    """,
    
    "trigger_processed_urls_updated": """
        CREATE TRIGGER update_processed_urls_last_updated
        BEFORE UPDATE ON processed_urls
        FOR EACH ROW
        EXECUTE FUNCTION update_last_updated_column();
    """,
    
    "trigger_detailed_auction_updated": """
        CREATE TRIGGER update_detailed_auction_last_updated
        BEFORE UPDATE ON detailed_auction_data
        FOR EACH ROW
        EXECUTE FUNCTION update_last_updated_column();
    """
}

class SupabaseClient:
    """Supabase client wrapper for auction data operations"""
    
    def __init__(self, use_service_role: bool = False):
        self.logger = logging.getLogger(__name__)
        key = SUPABASE_CONFIG["service_role_key"] if use_service_role else SUPABASE_CONFIG["key"]
        self.client: Client = create_client(SUPABASE_CONFIG["url"], key)
        
    def get_client(self) -> Client:
        """Get the Supabase client"""
        return self.client
    
    async def test_connection(self) -> bool:
        """Test the database connection"""
        try:
            result = self.client.table("vehicles").select("count").execute()
            return True
        except Exception as e:
            self.logger.error(f"Database connection test failed: {e}")
            return False
    
    def create_table(self, table_name: str) -> bool:
        """Create a table based on the table definition"""
        try:
            if table_name not in TABLE_DEFINITIONS:
                self.logger.error(f"Table definition not found: {table_name}")
                return False
            
            table_def = TABLE_DEFINITIONS[table_name]
            columns = table_def["columns"]
            
            # Build CREATE TABLE statement
            column_definitions = []
            for col_name, col_type in columns.items():
                column_definitions.append(f"{col_name} {col_type}")
            
            create_sql = f"""
                CREATE TABLE IF NOT EXISTS {table_name} (
                    {', '.join(column_definitions)}
                );
            """
            
            # Execute the CREATE TABLE statement
            self.client.rpc("execute_sql", {"sql": create_sql}).execute()
            
            # Create indexes
            if "indexes" in table_def:
                for index_sql in table_def["indexes"]:
                    self.client.rpc("execute_sql", {"sql": index_sql}).execute()
            
            # Add constraints
            if "constraints" in table_def:
                for constraint_sql in table_def["constraints"]:
                    self.client.rpc("execute_sql", {"sql": constraint_sql}).execute()
            
            self.logger.info(f"Table '{table_name}' created successfully")
            return True
            
        except Exception as e:
            self.logger.error(f"Error creating table '{table_name}': {e}")
            return False
    
    def create_all_tables(self) -> bool:
        """Create all tables defined in TABLE_DEFINITIONS"""
        success = True
        
        # Create tables in dependency order
        table_order = [
            "vehicles",
            "processed_urls",
            "detailed_auction_data",
            "staging_vehicles",
            "auction_sites",
            "manufacturers",
            "extraction_logs",
            "email_campaigns"
        ]
        
        for table_name in table_order:
            if not self.create_table(table_name):
                success = False
        
        # Create functions and triggers
        try:
            for func_name, func_sql in SQL_FUNCTIONS.items():
                self.client.rpc("execute_sql", {"sql": func_sql}).execute()
                self.logger.info(f"Created function/trigger: {func_name}")
        except Exception as e:
            self.logger.error(f"Error creating functions/triggers: {e}")
            success = False
        
        return success

# Helper functions for common operations
def get_supabase_client(use_service_role: bool = False) -> SupabaseClient:
    """Get a configured Supabase client"""
    return SupabaseClient(use_service_role)

def validate_config() -> bool:
    """Validate Supabase configuration"""
    required_vars = ["SUPABASE_URL", "SUPABASE_ANON_KEY"]
    
    for var in required_vars:
        if not os.getenv(var):
            print(f"Error: {var} environment variable is not set")
            return False
    
    # Check if URL format is valid
    url = os.getenv("SUPABASE_URL")
    if not url.startswith("https://") or not url.endswith(".supabase.co"):
        print("Error: Invalid SUPABASE_URL format")
        return False
    
    return True

# Export configuration
__all__ = [
    "SUPABASE_CONFIG",
    "DATABASE_CONFIG", 
    "LOGGING_CONFIG",
    "TABLE_DEFINITIONS",
    "SQL_FUNCTIONS",
    "SupabaseClient",
    "get_supabase_client",
    "validate_config"
] 